# How a Hacker Stole $566M USD Exploiting a Code Smell
            
![How a Hacker Stole $566M USD Exploiting a Code Smell](How%20a%20Hacker%20Stole%20$566M%20USD%20Exploiting%20a%20Code%20Smell.png)

*I am not a security expert. But I do love Clean Code and Code Smells*

> TL;DR: don't trust your hashes.

# The Hack

Yesterday, 2022 Oct 7th one of the larger blockchains had to be halted.

[This news](https://www.coindesk.com/business/2022/10/06/binance-linked-bnb-price-falls-close-to-4-on-hack-rumors/) was shocking since most blockchains are decentralized by definition.

Halting a large blockchain is not usual news.

[Web3 For Dummies - Part 01 - What is a Blockchain?](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Web3/Web3%20For%20Dummies%20-%20Part%2001%20-%20What%20is%20a%20Blockchain/readme.md)

It wasn't the [first one](https://biz.crast.net/terra-blockchain-paused-to-prevent-attacks-after-luna-token-crashes-almost-100-overnight/), either.

# The Reason

I pay attention to [blockchain](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Web3/Web3%20For%20Dummies%20-%20Part%2001%20-%20What%20is%20a%20Blockchain/readme.md) and security news.

This is far from my comfort zone when writing technical articles.

I've written more than 180 [code smells](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Code%20Smells/How%20to%20Find%20the%20Stinky%20parts%20of%20your%20Code/readme.md) and [refactorings](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Refactorings/Refactoring%20001%20-%20Remove%20Setters/readme.md).

There's always a tension between doing things in the right, clean way versus performance [optimization](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Code%20Smells/Code%20Smell%2020%20-%20Premature%20Optimization/readme.md).

Blockchains should be fast.

Many vulnerabilities are related to cryptic and optimized code.

This code would be unacceptable in many mission-critical large systems and codebases.

Performance and security are the main drivers on Web3, therefore blockchain and contracts code usually have exploits.

Clean code is not so easily exploitable.

# The Problem

I've read a lot of forensic analysis on the problem.

One of the best explanations is here:

[Twitter](https://x.com/1578167198203289600)

This [tweet](https://twitter.com/samczsun/status/1578167198203289600) has a lot of resources for research.

I will address its main ideas:

> What does matter is that due to the way that hash functions are intended to work, we can basically say with certainty that any (path, nleaf) pair will produce a unique hash. If we want to forge a proof, those will need to stay the same

> In summary, there was a bug in the way that the Binance Bridge verified proofs which could have allowed attackers to forge arbitrary messages. Fortunately, the attacker here only forged two messages, but the damage could have been far worse

> TL;DR: A hash function was exploited.

# The Hash

I've been using hashing functions for decades (not on blockchains of course).

There's been a lot of research on the math hashing functions.

We teach our students at the university about [hash collisions](https://en.wikipedia.org/wiki/Hash_collision) and how hard we create [math functions](https://en.wikipedia.org/wiki/Hash_function) to avoid them.

We also teach them some corollaries:

> Two objects with the same hash might not be the same.

> If we override an object's equality, we need to also override the hash.

The last one is very important for hashed collections.

A clean code lesson should be:

> Use (fast) hash for fast discard, and use (slow) equality to ensure you are right.

Now, I need to come back to my comfort zone and write this lesson in the standard code smell template I've been using for years.

If you like the format, you can read 166 more here: 

[How to Find the Stinky Parts of your Code](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Code%20Smells/How%20to%20Find%20the%20Stinky%20parts%20of%20your%20Code/readme.md)

# Image Credits

The beautiful image you see as the cover is a PNG image which hash is itself.

See the full story [here](https://twitter.com/David3141593/status/1573218394358386688):

%[https://twitter.com/David3141593/status/1573218394358386688]

And the code smell in the [series](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Code%20Smells/How%20to%20Find%20the%20Stinky%20parts%20of%20your%20Code/readme.md) format...

* * *

# Code Smell 167 - Hashing Comparison

*Hashing guarantees two objects are different. Not that they are the same*

> TL;DR: If you check for the hash, you should also check for equality

# Problems

- [Bijection fault](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Theory/The%20One%20and%20Only%20Software%20Design%20Principle/readme.md)

# Solutions

1. Check for hash (fast) and then check for Equality (slow)

# Sample Code

## Wrong

<!-- [Gist Url](https://gist.github.com/mcsee/b97afa5814c25e6d9c53e35f3fc5f09e) -->

```java
public class Person {
 
public String name;
// Public attributes are another smell  
 
 @Override
 public boolean equals(Person anotherPerson) {
   return name.equals(anotherPerson.name); 
 }
 	
@Override
 public int hashCode() {
   return (int)(Math.random()*256); 
 }
 // This is just an example of non-correlation  
 
 // When using HashMaps you can make a mistake 
 // and guess the object is not present in the collection
 
}
```

## Right

<!-- [Gist Url](https://gist.github.com/mcsee/4a40df553e8d08860b23f35fb4400c0e) -->

```java
public class Person {
 
public String name;
// Public attributes are another smell  
 
 @Override
 public boolean equals(Person anotherPerson) {
   return name.equals(anotherPerson.name); 
 }
 	
@Override
 public int hashCode() {
   return name.hashCode(); 
 }
 // This is just an example of non-correlation  
 
}
```

# Detection

[X] Semi-Automatic 

Many linters have rules for hash and equality redefinition.

With mutation testing, we can seed different objects with the same hash and check our tests.

# Tags

- Identity

- Security

# Conclusion

Every performance improvement has its drawbacks.

Caches and replications are notable examples.

We can (must) use them carefully.

# Relations

[Code Smell 49 - Caches](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Code%20Smells/Code%20Smell%2049%20-%20Caches/readme.md)

[Code Smell 150 - Equal Comparison](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Code%20Smells/Code%20Smell%20150%20-%20Equal%20Comparison/readme.md)

# More Info

[Equality and Hash](http://forum.world.st/Is-it-always-needed-to-redefine-hash-message-when-you-redefine-message-td4828721.html)

[Hashcode in Java](https://stackoverflow.com/questions/3563847/what-is-the-use-of-hashcode-in-java)

[Hashcode vs Equal](https://www.digitalocean.com/community/tutorials/java-equals-hashcode)

# Disclaimer

Code Smells are just my [opinion](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Blogging/I%20Wrote%20More%20than%2090%20Articles%20on%202021%20Here%20is%20What%20I%20Learned/readme.md).

* * *

> This will surprise some of your readers, but my primary interest is not with computer security. I am primarily interested in writing software that works as intended.

_Wietse Venema_
 
[Software Engineering Great Quotes](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Quotes/Software%20Engineering%20Great%20Quotes/readme.md)