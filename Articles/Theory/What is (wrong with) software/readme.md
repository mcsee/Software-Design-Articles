# What is (wrong with) software?

![What is (wrong with) software?](What%20is%20(wrong%20with)%20software.png)

*Software is eating the world. Those of us who work, live, and love software do not usually stop by to think about its meaning.*

> TL;DR: We will address current software design problems in a minimalist way.

In university and industry, we use the following definition of software:

> Software is a set of instructions that with certain input data generates output data.

This is the definition of a [computer program](https://en.wikipedia.org/wiki/Computer_program) according to *Wikipedia*:

> A **computer program** is a collection of [instructions](https://en.wikipedia.org/wiki/Instruction_set) that can be [executed](https://en.wikipedia.org/wiki/Execution_(computing)) by a [computer](https://en.wikipedia.org/wiki/Computer) to perform a specific task.

Many decades ago we understood that software is much more than a program.

We still don’t have good definitions of what is software.

Again, according to [Wikipedia](https://en.wikipedia.org/wiki/Software):

> **Computer software**, or simply **software**, is a collection of [data](https://en.wikipedia.org/wiki/Data_(computing)) or [computer](https://en.wikipedia.org/wiki/Computer) instructions that tell the computer how to work. This is in contrast to [physical hardware](https://en.wikipedia.org/wiki/Computer_hardware), from which the system is built and  performs the work.

The definition is by the complement (everything that is not hardware). Or by physical omission (everything that cannot be kicked and can only be cursed).

Yet, the only purpose we have whenever we build software that is:

> To mimic something that happens in a possible reality.

We are forgetting about the origins of modern programming languages ​​like [Simula](https://en.wikipedia.org/wiki/Simula).

Simula was the first object-oriented programming language to include classification.

In the language, it was clear from the name that the goal of software construction was to **build a simulator.**

This is the case with most computer software applications today.

Returning to the origins we can define the software as the construction of a:

> **(M)odel: (A)bstract (P)artial and (P)rogrammable (E)xplaining (R)eality.**

## Why is it a (M)odel? 

The model is the outcome of observing a certain aspect of reality.

Under a certain lens and a particular perspective with a certain paradigm.

It is not the truth revealed.

It is the best possible conception at a certain moment with the present knowledge. Since [Plato](https://www.tutorhunt.com/resource/10969/)’s time, human beings have tried to build good models of reality.

![The Cave](https://cdn.hashnode.com/res/hashnode/image/upload/v1598729025966/y0XMGW1_C.jpeg) 

Photo by [Max LaRochelle](https://unsplash.com/@maxlarochelle) on [Unsplash](https://unsplash.com/s/photos/cavern)

## Why is it a (A)bstract?

We can only understand and observe it with instruments such as a black box based on its behavior in the face of our stimuli.

Like Schrödinger’s [cat](https://en.wikipedia.org/wiki/Schr%C3%B6dinger%27s_cat).

We cannot know what state it is in without disturbing it with our measuring instruments.

The use case technique is an excellent tool to describe a model in a declarative way.

If you are not a declarative programmer, you might [lose your job](https://chatbotslife.com/most-programmers-are-losing-our-jobs-very-soon-77adf846beb1) very soon.

## Why is it (P)rogrammable? 

It has to run in some type of **simulator** that reproduces the desired conditions. 

It can be a [Turing model](https://en.wikipedia.org/wiki/Turing_machine) (current commercial computers), a quantum computer, or any type of simulator that can keep up with model evolution.

## Why is it (P)artial?

We will make a partial cut of the reality that interests us for the problem we are modeling.

This is common to scientific models.

Taking certain simplifications on aspects that do not interest us to isolate the problem.

![Full Scale Map](Full%20Scale%20Map.png)

A 1: 1 scale map of the earth would not make sense.

## Why is it (E)xplanatory?

The model must be declarative enough to let us observe its evolution.

It allows us to reason and predict behaviors in the reality we are modeling.

## Why is it about (R)eality? 

Because it has to reproduce conditions that occur in an observable environment.

The ultimate goal is to forecast the real world, like any simulation.

* * * * *

Once we define the software, we can begin to infer good modeling and
design practices.

## Starting Point 

We have the axiomatic definition presented in this article.

We will infer **principles**, **heuristics**, and **rules** to build excellent software models.

[The One and Only Software Design Principle](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Theory/The%20One%20and%20Only%20Software%20Design%20Principle/readme.md)

# Acknowledgements

These concepts are based on the thoughts of David West, Máximo Prieto and Hernán Wilkinson.

* * * * *

Part of the goal of this series of articles is to generate spaces for debate and discussion on software design.

[Object Design Checklist](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Theory/Object%20Design%20Checklist/readme.md)

We look forward to comments and suggestions on this article.

This article is published at the same time in Spanish [here](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Theory/What%20is%20(wrong%20with)%20software/readme.md).