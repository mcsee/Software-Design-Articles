# Laziness II - Code Wizards

![Laziness II - Code Wizards](Laziness%20II%20-%20Code%20Wizards.jpg)

*Code generators do our hard work. But we don’t need them anymore.*

> TL;DR: Don't use code wizards.

## Free lines of code

A few years ago working in the industry I took part on the demo of a programming product in which a *wizard *or *code generator *was used. The presenter boasted of writing less code, leaving the machine to write the text for her. Based on the templates that she was declaring.
The seduction argument consisted of writing less code. Today we know that this approach is completely wrong.
> If we have to tell the machine what the meta code is, it is because we are not being declarative enough.

There are several reasons:

a) We have not yet reached the level of abstraction and we have to teach the interpreter to make syntactic manipulations on our models.

If there is a certain redundancy, the usual approach would be to model that redundancy by searching in real-world against the abstract concept we should match.

[What is (wrong with) software?](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Theory/What%20is%20(wrong%20with)%20software/readme.md)

b) Some code generators are based on the (almost always incorrect) excuse that generated code is faster than the more declarative one used when including an indirection or abstraction. The performance argument almost always loses its support against a real benchmark. As a counterpart we can argue that to read or debug a function in general, the bunch of computer generated code confuses the novice programmer (and the experienced one wastes lost of time).

> Currently, human time is more valuable and scarce than machine time.

c) Some programming languages ​​impose arbitrary type restrictions that are only saved with intermediate code generation such as Java generics or templates in c++. These are language limitations and not model restrictions.
Non-declarative languages ​​like C++ or Java offer us with tools like [Templates](https://en.wikipedia.org/wiki/Template_(C%2B%2B)) or [Generics](https://en.wikipedia.org/wiki/Generics_in_Java) that [look different but are similar.](https://www.geeksforgeeks.org/templates-in-c-vs-generics-in-java/)

<!-- [Gist Url](https://gist.github.com/mcsee/cc4a2eaa2770317a964515925072175c) -->

```cpp
template <class T>
bool Linked_List<T>::isEmpty() {
}

void Linked_List<T>::append(T value) {
    generic_node<T> *new_node = new generic_node<T>;
}
```

![Code](https://cdn.hashnode.com/res/hashnode/image/upload/v1599511984360/ags0-9sW7.jpeg)

*Photo by [Shahadat Rahman](https://unsplash.com/@hishahadat) on [Unsplash](https://unsplash.com/s/photos/cryptic)*

d) The interpreter uses meta-programming to resolve these hints, although this is discouraged, among other reasons, for leaving obscure references, almost impossible to refactor and easily erasable by mistake.

[Laziness I - Metaprogramming](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Theory/Laziness%20I%20-%20Metaprogramming/readme.md)

e) The code generated with Wizards or with meta-programming is much darker, much more difficult to follow and violates the principle of failing fast because it does not usually know how to defend itself against possible invalid constructions.

We have the choice not to use it if we want to build good software models.

[Fail Fast](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Theory/Fail%20Fast/readme.md)

f) The code generated by the wizards, templates and [automatic code generation tools](https://en.wikipedia.org/wiki/Comparison_of_code_generation_tools) is of very low quality. It is not usually documented and generates coupling as it is a repetitive **cut&paste**. In case of finding an error in one of the generated fragments and, due to said coupling, we will have to correct it in multiple places violating the[ DRY principle.](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)

[Coupling - The one and only software design problem](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Theory/Coupling%20-%20The%20one%20and%20only%20software%20design%20problem/readme.md)

g) The generated code has little added value, and often encourages bad design practices like automatic *setters and getters *generation.

[Nude Models - Part I: Setters](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Theory/Nude%20Models - Part%20I Setters/readme.md)

[Nude Models - Part II: Getters](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Theory/Nude%20Models - Part%20II Getters/readme.md)

h) Finally, if computers can make inferences about the repetition of our design patterns, it is because we are not contributing the creative part (and for now not replicable) and we will be out of work in the short-term.

[Most Programmers are losing our jobs](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Opinion/(Most)%20Programmers%20are%20losing%20our%20jobs%20very%20soon/readme.md)

## The solution is on the usual shelf

Given the symptom of finding a pattern that is repeated in our code, the diagnosis is almost always the same:
> There is an abstraction or generalization in the domain of the problem that we have not yet discovered.

The trivial solution is to go, with the help of our favorite domain expert, to discover what **is the real-world concept** that encompasses repetition or pattern that the wizard or template did not allow us to discover.

![notes](https://cdn.hashnode.com/res/hashnode/image/upload/v1599511830774/-B05TXjIT.jpeg)

*Photo by [Volodymyr Hryshchenko](https://unsplash.com/@lunarts) on [Unsplash](https://unsplash.com/s/photos/detective)*

## Conclusions

Dynamic code generators were a fad at a time when productivity was measured based on the lines of code generated.
To avoid them, we must stay true to the rule of bijection and look for abstractions within the real-world in the problem domain.

Part of the objective of this series of articles is to generate spaces for debate and discussion on software design. 
We look forward to comments and suggestions on this article.

This article is also available in Spanish [here](https://github.com/mcsee/Software-Design-Articles/tree/main/Articles/Theory/Laziness%20II%20-%20Code%20Wizards/readme.md).